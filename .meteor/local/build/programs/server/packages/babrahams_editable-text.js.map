{"version":3,"sources":["meteor://ðŸ’»app/packages/babrahams_editable-text/lib/editable_text_common.js","meteor://ðŸ’»app/packages/babrahams_editable-text/lib/editable_text_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;;;;;;;;;;;;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C","file":"/packages/babrahams_editable-text.js","sourcesContent":["if (typeof EditableText === 'undefined') {\n  EditableText = {};\n}\n\n\n// ******************************************\n// CONFIG that affects BOTH CLIENT AND SERVER\n// ******************************************\n\nEditableText.userCanEdit = function(doc,Collection) {\n  // e.g. return doc.user_id = Meteor.userId();\n  return true;    \n}\n\nEditableText.useTransactions = (typeof tx !== 'undefined' && _.isObject(tx.Transactions)) ? true : false;\nEditableText.clientControlsTransactions = false;\n\nEditableText.maximumImageSize = 0; // Can't put image data in the editor by default\n\n// This is the set of defaults for sanitizeHtml on the server (as set by the library itself)\n// Required on the client for consistency of filtering on the paste event\nif (Meteor.isClient) {\n  sanitizeHtml = {};\n  sanitizeHtml.defaults = {\n    allowedTags: [ 'h3', 'h4', 'h5', 'h6', 'blockquote', 'p', 'a', 'ul', 'ol', 'nl', 'li', 'b', 'i', 'strong', 'em', 'strike', 'code', 'hr', 'br', 'div', 'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre' ],\n    allowedAttributes: { a: [ 'href', 'name', 'target' ] },\n    selfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],\n    allowedSchemes: [ 'http', 'https', 'ftp', 'mailto' ]  \n  };    \n}\n\nMeteor.startup(function () {\n  // The startup block is to allow apps to overwrite the sanitizeHtml defaults\n  EditableText.allowedHtml = {\n\tallowedTags: sanitizeHtml.defaults.allowedTags.concat(['sub', 'sup', 'font', 'u', 's', 'span']),\n\tallowedAttributes: _.extend(sanitizeHtml.defaults.allowedAttributes, {\n\t  font : ['size', 'face'],\n\t  div : ['align', 'style', 'class'],\n\t  span: ['style', 'class'],\n\t  table: ['style', 'class'],\n\t  td : ['rowspan', 'colspan', 'style', 'class'],\n\t  a: ['href', 'target', 'class'],\n\t  i: ['class']\n\t}),\n\tallowedSchemes:['http', 'https', 'ftp', 'mailto']\n  }\n});;\n\n\n// ******************************************\n// Functions that are intended for use in app\n// ******************************************\n\n// Function for setting multiple config variable via a hash\n\nEditableText.config = function(config) {\n  if (_.isObject(config)) {\n     _.each(config,function(val,key) {\n       if (_.contains(['userCanEdit','insert','update','remove'],key)) {\n         if (_.isFunction(val)) {\n           EditableText[key] = val;\n         }\n         else {\n           throw new Meteor.Error(key + ' must be a function');\n         }\n       }\n       if (_.contains(['useTransactions','clientControlsTransactions','saveOnFocusout','trustHtml','useMethods'],key)) {\n         if (_.isBoolean(val)) {\n           EditableText[key] = val;\n         }\n         else {\n           throw new Meteor.Error(key + ' must be a boolean');\n         }\n       }\n       if (_.contains(['collection2Options'], key)) {\n         if (_.isObject(val)) {\n            EditableText[key] = val;\n         }\n       }\n     });\n  }\n  else {\n    throw new Meteor.Error('Editable text config object must be a hash of key value pairs. Config not changed.');  \n  }\n}\n\n// Function for registering callbacks\n\nEditableText.registerCallbacks = function(obj) {\n  if (_.isObject(obj)) {\n    _.each(obj,function(val,key) {\n      if (_.isFunction(val)) {\n        EditableText._callbacks[key] = val;\n      }\n      else {\n        throw new Meteor.Error('Callbacks need to be functions. You passed a ' + typeof(val) + '.');    \n      }\n    });\n  }\n  else {\n    throw new Meteor.Error('You must pass an object to register callbacks');  \n  }\n}\n\n\n// *********************************\n// INTERNAL PROPERTIES AND FUNCTIONS\n// *********************************\n\nEditableText._callbacks = {};\n\nEditableText._mutatedDocIsObject = function (mutatedDoc) {\n  return _.isObject(mutatedDoc) && !_.isArray(mutatedDoc) && !_.isDate(mutatedDoc) && !_.isFunction(mutatedDoc); // Just want real key-value pair type objects\n}\n\nEditableText._callback = function(callback, doc, originalValue) {\n  // Note: 'beforeUpdate' and 'beforeInsertMultiple' callbacks are special-cased to use return values of any type, not just objects\n  // originalValue is only set on beforeUpdate and beforeInsertMultiple callbacks. It is of the form { value: <actual original value> }\n  // otherwise originalValue should be undefined\n  callback = String(callback);\n  var self = this;\n  var callbackRan = false;\n  if (self[callback] && _.isString(self[callback])) {\n    var mutatedDoc = EditableText._executeCallback(self[callback], self, doc, originalValue);\n\tcallbackRan = true;\n\tvar mutatedDocIsObject = EditableText._mutatedDocIsObject(mutatedDoc);\n\tif (!originalValue && !mutatedDocIsObject) {\n\t  throw new Meteor.Error('Wrong type returned', 'Your callback function \"' + callback + '\" returned a ' + typeof mutatedDoc + '. An object was expected.');\t\n\t}\n    doc = (originalValue) ? mutatedDoc : mutatedDocIsObject && mutatedDoc || doc;\n  }\n  if (originalValue) {\n\t// if the callback hasn't run, then the\n\t// doc is still the whole document,\n\t// not the new value for the field\n\tif (!callbackRan) {\n\t  doc = originalValue.value;\t\n\t}\n\tif (callbackRan && mutatedDocIsObject && (_.has(doc, '$set') || _.has(doc, '$addToSet') || _.has(doc, '$push'))) {\n\t  return {modifier: doc};\n\t}\n\telse {\n\t  return {value: doc};  \n\t}\n  }\n  return doc;\n}\n\nEditableText._executeCallback = function(callbackFunctionName, self, doc, originalValue) { // originalValue.value is the default to return if no updates have been made\n  var mutatedDoc = (originalValue && {value: originalValue.value}) || doc;\n  var callbackFunction = EditableText._callbacks[callbackFunctionName];\n  if (callbackFunction && _.isFunction(callbackFunction)) {\n    callbackMutatedDoc = callbackFunction.call(self, doc, Mongo.Collection.get(self.collection), originalValue && originalValue.value || undefined, originalValue && originalValue.modifier || undefined);\n\tif (!_.isUndefined(callbackMutatedDoc)) {\n\t  mutatedDoc = callbackMutatedDoc;\n\t}\n  }\n  else {\n    throw new Meteor.Error('Callback not a function', 'Could not execute callback. Reason: ' + ((callbackFunction) ? '\"' + callbackFunctionName + '\" is not a function, it\\'s a ' + typeof(callbackFunction) + '.' : 'no callback function called \"' + callbackFunctionName + '\" has been registered via EditableText.registerCallbacks.'));    \n  }\n  return mutatedDoc;\n}\n\nEditableText._drillDown = function(obj,key) {\n  return Meteor._get.apply(null,[obj].concat(key.split('.')));\n}\n\nEditableText._allowedHtml = function() {\n  var allowed = EditableText.allowedHtml;\n  if (EditableText.maximumImageSize && _.isNumber(EditableText.maximumImageSize) && allowed) {\n    allowed.allowedTags.push('img');\n    allowed.allowedAttributes.img = ['src'];\n    allowed.allowedSchemes.push('data'); \n  }\n  return allowed;\n}\n\n\n// *************\n// UPDATE METHOD\n// *************\n\nMeteor.methods({\n  _editableTextWrite : function (action, data, modifier, transaction) {\n    check(action, String);\n    check(data, Object);\n    check(data.collection, String);\n    check(data.context, (typeof FS !== \"undefined\" && FS.File) ? Match.OneOf(Object, FS.File) : Object);\n    check(modifier, (action === 'update') ? Object : null);\n    check(transaction, Boolean);\n    check(data.objectTypeText, Match.OneOf(String, undefined));\n    var hasPackageCollection2 = !!Package['aldeed:collection2'];\n    var hasPackageSimpleSchema = !!Package['aldeed:simple-schema'];\n    var Collection = Mongo.Collection.get(data.collection);\n    var c2optionsHashRequired = hasPackageCollection2 && hasPackageSimpleSchema && _.isFunction(Collection.simpleSchema) && Collection._c2;\n    if (Collection && EditableText.userCanEdit.call(data, data.context, Collection)) {\n\t  if (Meteor.isServer) {\n        if (_.isBoolean(EditableText.useTransactions) && !EditableText.clientControlsTransactions) {\n          transaction = EditableText.useTransactions;\n        }\n      }\n      if (typeof tx === 'undefined') {\n        transaction = false;    \n      }\n      var setStatus = function (err, res) {\n        data.status = {error: err, result: res};    \n      }\n\t  var options = (transaction) ? {instant: true} : {};\n      if (c2optionsHashRequired) {\n        options = _.extend(options, EditableText.collection2options || {});    \n      }\n      switch (action) {\n        case 'insert' :\n          if (Meteor.isServer) {\n            // run all string fields through sanitizeHtml\n            data.context = EditableText.sanitizeObject(data.context);\n          }\n          if (transaction) {\n            if (data.objectTypeText || data.transactionInsertText) {\n              tx.start(data.transactionInsertText || 'add ' + data.objectTypeText);\n            }\n            data.context = EditableText._callback.call(data, 'beforeInsert', data.context) || data.context;\n            var new_id = tx.insert(Collection, data.context, options, setStatus);\n            EditableText._callback.call(data, 'afterInsert', Collection.findOne({_id: new_id}));\n            if (data.objectTypeText || data.transactionInsertText) {\n              tx.commit();\n            }\n          }\n          else {\n            data.context = EditableText._callback.call(data,'beforeInsert',data.context) || data.context;\n            var new_id = (c2optionsHashRequired) ? Collection.insert(data.context,options,setStatus) : Collection.insert(data.context, setStatus);\n            EditableText._callback.call(data, 'afterInsert', Collection.findOne({_id: new_id}));\n          }\n          return new_id;\n          break;\n        case 'update' :\n          if (Meteor.isServer) {\n            var newValue, sanitized = false;\n            if (modifier[\"$set\"] && _.isString(modifier[\"$set\"][data.field])) {\n            // run through sanitizeHtml\n              newValue = modifier[\"$set\"][data.field] = EditableText.sanitizeString(modifier[\"$set\"][data.field], data.wysiwyg || !!data.editor);\n              sanitized = true;\n            }\n            if (modifier[\"$set\"] && _.isArray(modifier[\"$set\"][data.field])) {\n              newValue = modifier[\"$set\"][data.field] = _.map(modifier[\"$set\"][data.field],function (str) {return EditableText.sanitizeString(str, data.wysiwyg || !!data.editor);});\n              sanitized = true;\n            }\n            if (modifier[\"$set\"] && _.isNumber(modifier[\"$set\"][data.field])) {\n              newValue = modifier[\"$set\"][data.field];\n              sanitized = true;    \n            }\n            if (modifier[\"$addToSet\"] && _.isString(modifier[\"$addToSet\"][data.field])) {\n              newValue = modifier[\"$addToSet\"][data.field] = EditableText.sanitizeString(modifier[\"$addToSet\"][data.field], data.wysiwyg || !!data.editor);\n              sanitized = true;    \n            }\n            if (modifier[\"$push\"] && _.isString(modifier[\"$push\"][data.field])) {\n              newValue = modifier[\"$push\"][data.field] = EditableText.sanitizeString(modifier[\"$push\"][data.field], data.wysiwyg || !!data.editor);\n              sanitized = true;    \n            }\n            if (!sanitized) {\n              throw new Meteor.Error('Wrong data type sent for update');\n\t\t\t  return; \n            }\n          }\n          else {\n            newValue = (modifier[\"$set\"] && (modifier[\"$set\"][data.field] || (data.type !== 'number' && modifier[\"$set\"][data.field] === '') || (data.type === 'number' && modifier[\"$set\"][data.field] === 0))) || (modifier[\"$addToSet\"] && modifier[\"$addToSet\"][data.field]) || (modifier[\"$push\"] && modifier[\"$push\"][data.field]);\n          }\n          data.newValue = newValue;\n          data.oldValue = EditableText._drillDown(data.context, data.field);\n\t\t  var callbackModifier = function (modifier, key, val) {\n\t\t\t/*if (val === undefined) {\n\t\t\t  return modifier;\n\t\t\t}*/\n\t\t\tvar modifierTypes = [\"$set\", \"$addToSet\", \"$push\"];\n\t\t\tvar modType = _.find(modifierTypes, function (mt) {\n\t\t\t  return _.has(modifier, mt);\n\t\t\t});\n\t\t\tif (modType) {\n\t\t\t  modifier[modType][key] = val;\n\t\t\t}\n\t\t\treturn modifier;\n\t\t  }\n          if (transaction) {\n            if (data.transactionUpdateText || data.objectTypeText) {\n              tx.start(data.transactionUpdateText || 'update ' + data.objectTypeText);\n            }\n            var newVal = EditableText._callback.call(data,'beforeUpdate',data.context, {value: data.newValue, modifier: modifier}); // By setting the fourth parameter, we are expecting a value, not the whole doc, to be returned from the callback\n\t\t\tmodifier = callbackModifier(newVal.modifier || modifier, data.field, newVal.value);\n            tx.update(Collection,data.context._id, modifier, options, setStatus);\n            EditableText._callback.call(data, 'afterUpdate', Collection.findOne({_id: data.context._id}));\n            if (data.transactionUpdateText || data.objectTypeText) {\n              tx.commit();\n            }\n          }\n          else {\n            var newVal = EditableText._callback.call(data, 'beforeUpdate', data.context, {value: data.newValue, modifier: modifier});\n\t\t\tmodifier = callbackModifier(newVal.modifier || modifier, data.field, newVal.value);\n            if (c2optionsHashRequired) {\n              Collection.update({_id: data.context._id}, modifier, options, setStatus);\n            }\n            else {\n              Collection.update({_id: data.context._id}, modifier, setStatus);\n            }\n            EditableText._callback.call(data, 'afterUpdate', Collection.findOne({_id: data.context._id}));\n          }\n          break;\n        case 'remove' :\n          if (transaction) {\n            if (data.transactionRemoveText || data.objectTypeText) {\n              tx.start(data.transactionRemoveText || 'remove ' + data.objectTypeText);\n            }\n            data.context = EditableText._callback.call(data, 'beforeRemove', data.context) || data.context;\n            tx.remove(Collection, data.context._id, {instant: true}, setStatus);\n            EditableText._callback.call(data, 'afterRemove', data.context);\n            if (data.transactionRemoveText || data.objectTypeText) {\n              tx.commit();\n            } \n          }\n          else {\n            data.context = EditableText._callback.call(data, 'beforeRemove', data.context) || data.context;\n            Collection.remove({_id: data.context._id}, setStatus);\n            EditableText._callback.call(data, 'afterRemove', data.context);\n          }\n          break;  \n      }\n    }\n  }\n});","if (typeof EditableText === 'undefined') {\n  EditableText = {};\n}\n\n// Only used in the _editableTextWrite method detects the presence of aldeed:collection2\nEditableText.collection2Options = {filter: true, validate: true};\n\nEditableText.sanitizeString = function(string, html) {\n  var sanitizedString = (html) ? sanitizeHtml(string, EditableText._allowedHtml()) : EditableText.stripTags(string);\n  /*if (string !== sanitizedString) {\n    console.log(\"Sanitized: \", string);\n    console.log(\"To: \", sanitizedString);  \n  }*/\n  return sanitizedString;\n}\n\nEditableText.sanitizeObject = function(obj) {\n  _.each(obj,function(val,key) {\n    if (_.isString(obj[key])) {\n      var original = obj[key];\n\t  // FIrst check if stripTags has an effect\n\t  // If so, assume it's html and put the string through the html sanitizer\n\t  // TODO - check with people who know more about XSS whether this leaves a security hole\n\t  if (obj[key] !== EditableText.stripTags(obj[key])) {\n\t\tvar html = true;\n        obj[key] = EditableText.sanitizeString(obj[key], html);\n        if (original !== obj[key]) {\n          console.log(\"Sanitized: \", original);\n          console.log(\"To: \", obj[key]);  \n        }\n\t  }\n    }\n    // If it's another object, need to recurse into that object and clean up strings\n    if (_.isObject(obj[key])) {\n      obj[key] = EditableText.sanitizeObject(obj[key]);\n    }\n  });\n  return obj;\n}\n\nEditableText.stripTags = function(input) { // stolen from phpjs.org\n  // var allowed = '';\n  /*allowed = (((allowed || '') + '')\n    .toLowerCase()\n    .match(/<[a-z][a-z0-9]*>/g) || [])\n    .join(''); // making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)*/\n  var tags = /<\\/?([a-z][a-z0-9]*)\\b[^>]*>/gi,\n    comments = /<!--[\\s\\S]*?-->/gi;\n  return input.replace(comments, '')\n    .replace(tags, '' /*function($0, $1) {\n      return allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';\n    }*/);\t\n}"]}