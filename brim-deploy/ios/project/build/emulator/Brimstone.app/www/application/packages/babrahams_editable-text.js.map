{"version":3,"sources":["meteor://ðŸ’»app/packages/babrahams_editable-text/lib/template.editable_text.js","meteor://ðŸ’»app/packages/babrahams_editable-text/lib/editable_text.js","meteor://ðŸ’»app/packages/babrahams_editable-text/lib/editable_text_common.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;;;;;;;;ACldA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H","file":"/packages/babrahams_editable-text.js","sourcesContent":["\nTemplate.__checkName(\"editableText\");\nTemplate[\"editableText\"] = new Template(\"Template.editableText\", (function() {\n  var view = this;\n  return Blaze._TemplateWith(function() {\n    return {\n      context: Spacebars.call(view.lookup(\"context\")),\n      collection: Spacebars.call(view.lookup(\"collection\")),\n      field: Spacebars.call(view.lookup(\"field\")),\n      value: Spacebars.call(view.lookup(\"value\")),\n      editingValue: Spacebars.call(view.lookup(\"editingValue\")),\n      textarea: Spacebars.call(view.lookup(\"textarea\")),\n      wysiwyg: Spacebars.call(view.lookup(\"wysiwyg\")),\n      acceptEmpty: Spacebars.call(view.lookup(\"acceptEmpty\")),\n      removeEmpty: Spacebars.call(view.lookup(\"removeEmpty\")),\n      eventType: Spacebars.call(view.lookup(\"eventType\")),\n      type: Spacebars.call(view.lookup(\"type\")),\n      objectTypeText: Spacebars.call(view.lookup(\"objectTypeText\")),\n      \"class\": Spacebars.call(view.lookup(\"class\")),\n      inputClass: Spacebars.call(view.lookup(\"inputClass\")),\n      autoInsert: Spacebars.call(view.lookup(\"autoInsert\")),\n      beforeInsert: Spacebars.call(view.lookup(\"beforeInsert\")),\n      afterInsert: Spacebars.call(view.lookup(\"afterInsert\")),\n      wysiwygStyle: Spacebars.call(view.lookup(\"wysiwygStyle\")),\n      style: Spacebars.call(view.lookup(\"style\")),\n      inputStyle: Spacebars.call(view.lookup(\"inputStyle\")),\n      substitute: Spacebars.call(view.lookup(\"substitute\")),\n      title: Spacebars.call(view.lookup(\"title\")),\n      userCanEdit: Spacebars.call(view.lookup(\"userCanEdit\")),\n      useTransaction: Spacebars.call(view.lookup(\"useTransaction\")),\n      beforeUpdate: Spacebars.call(view.lookup(\"beforeUpdate\")),\n      afterUpdate: Spacebars.call(view.lookup(\"afterUpdate\")),\n      beforeRemove: Spacebars.call(view.lookup(\"beforeRemove\")),\n      afterRemove: Spacebars.call(view.lookup(\"afterRemove\")),\n      onStartEditing: Spacebars.call(view.lookup(\"onStartEditing\")),\n      onStopEditing: Spacebars.call(view.lookup(\"onStopEditing\")),\n      onShowToolbar: Spacebars.call(view.lookup(\"onShowToolbar\")),\n      onHideToolbar: Spacebars.call(view.lookup(\"onHideToolbar\")),\n      placeholder: Spacebars.call(view.lookup(\"placeholder\")),\n      saveOnFocusout: Spacebars.call(view.lookup(\"saveOnFocusout\")),\n      noSaveOnReturn: Spacebars.call(view.lookup(\"noSaveOnReturn\")),\n      dontSelectAll: Spacebars.call(view.lookup(\"dontSelectAll\")),\n      showSaveButton: Spacebars.call(view.lookup(\"showSaveButton\")),\n      trustHtml: Spacebars.call(view.lookup(\"trustHtml\")),\n      useMethod: Spacebars.call(view.lookup(\"useMethod\")),\n      toolbarPosition: Spacebars.call(view.lookup(\"toolbarPosition\")),\n      options: Spacebars.call(view.lookup(\"options\")),\n      autoResize: Spacebars.call(view.lookup(\"autoResize\")),\n      emptyText: Spacebars.call(view.lookup(\"emptyText\")),\n      showToolbar: Spacebars.call(view.lookup(\"showToolbar\")),\n      derivedOptions: Spacebars.call(view.lookup(\"derivedOptions\")),\n      template: Spacebars.call(view.lookup(\"template\")),\n      stopPropagation: Spacebars.call(view.lookup(\"stopPropagation\")),\n      editor: Spacebars.call(view.lookup(\"editor\")),\n      editorOptions: Spacebars.call(view.lookup(\"editorOptions\"))\n    };\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"editable_text_widget\"));\n  });\n}));\n\nTemplate.__checkName(\"editable_text_widget\");\nTemplate[\"editable_text_widget\"] = new Template(\"Template.editable_text_widget\", (function() {\n  var view = this;\n  return Spacebars.With(function() {\n    return Spacebars.call(view.lookup(\"initOptions\"));\n  }, function() {\n    return Blaze.If(function() {\n      return Spacebars.call(view.lookup(\"controlTemplate\"));\n    }, function() {\n      return Blaze._TemplateWith(function() {\n        return {\n          template: Spacebars.call(view.lookup(\"controlTemplate\")),\n          data: Spacebars.call(view.lookup(\"controlData\"))\n        };\n      }, function() {\n        return Spacebars.include(function() {\n          return Spacebars.call(Template.__dynamic);\n        });\n      });\n    }, function() {\n      return Blaze.If(function() {\n        return Spacebars.call(view.lookup(\"editing\"));\n      }, function() {\n        return Blaze.If(function() {\n          return Spacebars.call(view.lookup(\"textarea\"));\n        }, function() {\n          return [ Blaze.If(function() {\n            return Spacebars.call(view.lookup(\"showSaveButton\"));\n          }, function() {\n            return HTML.BUTTON({\n              \"class\": \"editable-text-save-button\"\n            }, \"Save\");\n          }), HTML.TEXTAREA({\n            \"class\": function() {\n              return [ \"text-area-edit \", Spacebars.mustache(view.lookup(\"inputClass\")) ];\n            },\n            placeholder: function() {\n              return Spacebars.mustache(view.lookup(\"placeholder\"));\n            },\n            title: function() {\n              return Blaze.If(function() {\n                return Spacebars.call(view.lookup(\"trustHtml\"));\n              }, function() {\n                return \"Hold SHIFT and press ENTER for a new line\";\n              });\n            },\n            style: function() {\n              return Spacebars.mustache(view.lookup(\"inputStyle\"));\n            },\n            value: function() {\n              return Spacebars.mustache(view.lookup(\"value\"));\n            }\n          }) ];\n        }, function() {\n          return Blaze.If(function() {\n            return Spacebars.call(view.lookup(\"isWysiwyg\"));\n          }, function() {\n            return HTML.DIV({\n              \"class\": \"wysiwyg-container\"\n            }, Blaze.If(function() {\n              return Spacebars.dataMustache(view.lookup(\"toolsPosition\"), \"top\");\n            }, function() {\n              return Spacebars.include(view.lookupTemplate(\"wysiwyg\"));\n            }), HTML.DIV({\n              \"class\": function() {\n                return [ \"wysiwyg \", Spacebars.mustache(view.lookup(\"inputClass\")) ];\n              },\n              style: function() {\n                return Spacebars.mustache(view.lookup(\"inputStyle\"));\n              }\n            }, Blaze.View(\"lookup:wysiwygContent\", function() {\n              return Spacebars.mustache(view.lookup(\"wysiwygContent\"));\n            })), Blaze.Unless(function() {\n              return Spacebars.dataMustache(view.lookup(\"toolsPosition\"), \"top\");\n            }, function() {\n              return Spacebars.include(view.lookupTemplate(\"wysiwyg\"));\n            }));\n          }, function() {\n            return HTML.INPUT({\n              \"class\": function() {\n                return [ \"wide-text-edit \", Spacebars.mustache(view.lookup(\"inputClass\")) ];\n              },\n              type: \"text\",\n              value: function() {\n                return Spacebars.mustache(view.lookup(\"inputValue\"));\n              },\n              placeholder: function() {\n                return Spacebars.mustache(view.lookup(\"placeholder\"));\n              },\n              style: function() {\n                return Spacebars.mustache(view.lookup(\"inputStyle\"));\n              }\n            });\n          });\n        });\n      }, function() {\n        return Blaze.If(function() {\n          return Spacebars.call(view.lookup(\"canEditText\"));\n        }, function() {\n          return Blaze.If(function() {\n            return Spacebars.call(view.lookup(\"substitute\"));\n          }, function() {\n            return HTML.SPAN({\n              title: function() {\n                return Spacebars.mustache(view.lookup(\"title\"));\n              },\n              \"class\": function() {\n                return [ \"editable-text \", Spacebars.mustache(view.lookup(\"class\")), \" et-\", Spacebars.mustache(Spacebars.dot(view.lookup(\"context\"), \"_id\")) ];\n              }\n            }, Blaze.View(\"lookup:substitute\", function() {\n              return Spacebars.mustache(view.lookup(\"substitute\"));\n            }));\n          }, function() {\n            return Blaze.If(function() {\n              return Spacebars.call(view.lookup(\"isWysiwyg\"));\n            }, function() {\n              return HTML.DIV({\n                \"class\": \"wysiwyg-content\"\n              }, HTML.DIV({\n                \"class\": function() {\n                  return [ \"editable-text \", Spacebars.mustache(view.lookup(\"class\")), \" et-\", Spacebars.mustache(Spacebars.dot(view.lookup(\"context\"), \"_id\")) ];\n                },\n                title: function() {\n                  return Spacebars.mustache(view.lookup(\"title\"));\n                },\n                style: function() {\n                  return Spacebars.mustache(view.lookup(\"style\"));\n                }\n              }, Blaze.View(\"lookup:wysiwygContent\", function() {\n                return Spacebars.mustache(view.lookup(\"wysiwygContent\"));\n              })));\n            }, function() {\n              return HTML.SPAN({\n                \"class\": function() {\n                  return [ \"editable-text \", Spacebars.mustache(view.lookup(\"class\")), \" et-\", Spacebars.mustache(Spacebars.dot(view.lookup(\"context\"), \"_id\")) ];\n                },\n                title: function() {\n                  return Spacebars.mustache(view.lookup(\"title\"));\n                }\n              }, Blaze.View(\"lookup:content\", function() {\n                return Spacebars.mustache(view.lookup(\"content\"));\n              }));\n            });\n          });\n        }, function() {\n          return Spacebars.With(function() {\n            return Spacebars.dataMustache(view.lookup(\"substitute\"), true);\n          }, function() {\n            return Blaze.View(\"lookup:.\", function() {\n              return Spacebars.mustache(view.lookup(\".\"));\n            });\n          }, function() {\n            return Blaze.If(function() {\n              return Spacebars.call(view.lookup(\"isWysiwyg\"));\n            }, function() {\n              return Blaze.View(\"lookup:wysiwygContent\", function() {\n                return Spacebars.mustache(view.lookup(\"wysiwygContent\"));\n              });\n            }, function() {\n              return Blaze.View(\"lookup:content\", function() {\n                return Spacebars.mustache(view.lookup(\"content\"));\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n}));\n","EditableText = {};\n\n// *******************************\n// CONFIG that only affects CLIENT\n// *******************************\n\nEditableText.saveOnFocusout = true;\nEditableText.trustHtml = false;\nEditableText.useMethods = true; // only set this to false if you really know what you're doing and have taken appropriate measures to thwart XSS attacks\nEditableText.editors = {}; // where other packages register different editors that can supplant the UI functionality of this package, while using the mutator methods it makes available\nEditableText.isTouchDevice = ('ontouchstart' in document.documentElement);\n\n// The `EditableText.insert`, `EditableText.update`, `EditableText.remove` functions can be optionally overwritten if necessary\n// Not recommended, though. It's a lot of work to get the same functionality that the package provides by default\n\nEditableText.insert = function (Collection, doc) {\n  var self = _.clone(this); // Don't want to update the original\n  if (EditableText.useMethods && this.useMethod !== false || this.useMethod) {\n    var objId = Random.id();\n    self.context = _.clone(self.context); // need to clone this field again because this.context is an object and _.clone isn't a deep clone\n    self.context._id = objId;\n    Meteor.call('_editableTextWrite', 'insert', self, null, EditableText._useTransaction(this), function (err, res) {\n      if (err) {\n        console.log(err);\n        return;  \n      }\n      // Just in case it didn't get into the DOM in time\n      /*Tracker.flush();\n      var elem = $('.et-' + objId);\n      if (elem.length) {\n        elem.eq(0).trigger((EditableText.wysiwyg && self.wysiwyg) ? 'mousedown' : 'click');\n      }*/\n    });\n    // TODO -- this new object needs to get `selected` set in its template instance (and the corresponding element needs to gain focus) wherever it lands in the DOM\n    // However, we have no easy way of getting its template instance, other than iterating over\n    // all template instances, looking for the one where the context._id matches the object_id value\n    // Unfortunately, I have no idea where the template instances are stored\n    // So using a filthy hack instead ...\n    // Getting the element(s) in the DOM with the right class and firing click event on the first one\n    // Too bad if this wasn't the element we really wanted to be editing\n    // Note: we can't fire events on them all as, if there are (even temporarily) duplicates in the DOM and removeEmpty=true, this could cause unwanted side effects (e.g. instant deletion after creation)\n    // This means that in cases when the newly inserted document field is available in multiple places on the screen, the wrong one might be selected for editing (i.e. one that wasn't where the user clicked)\n    // This is probably rare enough that we'll ignore it until it becomes a serious problem, at which time we'll come up with another hack\n    Tracker.flush(); // Put this here rather than in the callback to maintain latency compensation\n    var elem = $('.et-' + objId);\n    if (elem.length) {\n      elem.eq(0).trigger((EditableText.wysiwyg && self.wysiwyg) ? 'mousedown' : 'click');\n    }\n    return;\n  }\n  if (EditableText._useTransaction(this)) {\n    if (this.transactionInsertText || this.objectTypeText) {\n      tx.start(this.transactionInsertText || 'add ' + this.objectTypeText);  \n    }\n    EditableText._callback.call(self, 'beforeInsert', self.context);\n    var new_id = tx.insert(Collection, doc, {instant: true});\n    EditableText._callback.call(self, 'afterInsert', Collection.findOne({_id: new_id}));\n    if (this.transactionInsertText || this.objectTypeText) {\n      tx.commit();  \n    }\n  }\n  else {\n    doc = EditableText._callback.call(self, 'beforeInsert', self.context);\n    var new_id = Collection.insert(doc);\n    EditableText._callback.call(self, 'afterInsert', Collection.findOne({_id: new_id}));\n  }\n  // see above\n  Tracker.flush();\n  $('.et-' + new_id).eq(0).trigger((EditableText.wysiwyg && this.wysiwyg) ? 'mousedown' : 'click');\n  return new_id;\n}\n\nEditableText.update = function(Collection, doc, modifier) {\n  var self = this;\n  if (EditableText.useMethods && this.useMethod !== false || this.useMethod) {\n    Meteor.call('_editableTextWrite', 'update', this, modifier, EditableText._useTransaction(this), function (err, res) {\n      if (err) {\n        console.log(err);\n      }\n    });\n    return;\n  }\n  if (EditableText._useTransaction(this)) {\n    if (this.objectTypeText || this.transactionUpdateText) {\n      tx.start(this.transactionUpdateText || 'update ' + this.objectTypeText);  \n    }\n    EditableText._callback.call(self, 'beforeUpdate', doc);\n    // Important to send the id only, not the whole document (\"self\"),\n    // as this update is fired from all sorts of contexts, some of which are incomplete -- \n    // this will force the transaction script to find the relevant document with its full context from the database\n    tx.update(Collection, doc._id, modifier, {instant: true});\n    EditableText._callback.call(self, 'afterUpdate', Collection.findOne({_id: doc._id}));\n    if (this.objectTypeText || this.transactionUpdateText) {\n      tx.commit();  \n    }\n  }\n  else {\n    EditableText._callback.call(self, 'beforeUpdate', doc);\n    Collection.update({_id: doc._id}, modifier);\n    EditableText._callback.call(self, 'afterUpdate', Collection.findOne({_id: doc._id}));\n  }\n}\n\nEditableText.remove = function(Collection, doc) {\n  var self = this;\n  if (EditableText.useMethods && this.useMethod !== false || this.useMethod) {\n    Meteor.call('_editableTextWrite', 'remove', this, null, EditableText._useTransaction(this), function (err, res) {\n      if (err) {\n        console.log(err);\n      }\n    });\n    return;\n  }\n  if (EditableText._useTransaction(this)) {\n    if (this.objectTypeText || this.transactionRemoveText) {\n      tx.start(this.transactionRemoveText || 'remove ' + this.objectTypeText);  \n    }\n    EditableText._callback.call(self,'beforeRemove',doc);\n    tx.remove(Collection,doc._id,{instant:true});\n    EditableText._callback.call(self,'afterRemove',Collection.findOne({_id:doc._id}));\n    if (this.objectTypeText || this.transactionRemoveText) {\n      tx.commit();  \n    }\n  }\n  else {\n    EditableText._callback.call(self,'beforeRemove',doc);\n    Collection.remove({_id:doc._id});\n    EditableText._callback.call(self,'afterRemove',Collection.findOne({_id:doc._id}));\n  }\n}\n\n\n// *********************************\n// INTERNAL PROPERTIES AND FUNCTIONS\n// *********************************\n\nEditableText._removeEntities = function (html) {\n  return $.trim(html.replace(/&quot;/g, '\"').replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/&nbsp;/g, ' '));\n}\n\n/*EditableText._linkify = function (text) {\n  return autolinker.link(text);\n}*/\n\nEditableText._useTransaction = function (data) {\n  return !!(typeof tx !== 'undefined' && ((EditableText.useTransactions && data.useTransaction !== false) || data.useTransaction));    \n}\n\nEditableText.__blockOkayEvent = false;\nEditableText.__blockEditEvent = false;\n\nTemplate.editableText.helpers({\n  context : function () {\n    return this.context || this.document || this.doc || this.object || this.obj || this.data || this.dataContext || Blaze._parentData(1);\n  }\n});\n\n// Returns an event map that handles the \"escape\" and \"return\" keys and\n// \"blur\" events on a text input (given by selector) and interprets them\n// as \"ok\" or \"cancel\".\n\nEditableText._okCancelEvents = function (selector, callbacks, acceptEmpty) {\n  var ok = callbacks.ok || function () {};\n  var cancel = callbacks.cancel || function () {};\n  var events = {};\n  events['keydown '+selector+', focusout '+selector] =\n    function (evt, tmpl) {\n      evt.stopImmediatePropagation();\n      var charCode = evt.which || evt.keyCode;\n      var value = $.trim(String($(evt.target).val() || \"\"));\n      if (evt.type === \"keydown\") {\n        switch (charCode) {\n          case 27 : // escape = cancel\n            cancel.call(this, value, evt, tmpl);\n            break;\n        }\n      }\n      if (evt.type === \"keydown\" && (charCode === 13 && !(evt.shiftKey || (typeof this.noSaveOnReturn !== 'undefined' && this.noSaveOnReturn))) || (evt.type === \"focusout\" && ((typeof this.saveOnFocusout !== 'undefined' && this.saveOnFocusout) || (typeof this.saveOnFocusout === 'undefined' && EditableText.saveOnFocusout)))) {\n        evt.preventDefault();\n        // blur/return/enter = ok/submit if non-empty\n        if ((value || (this.type === 'number' && parseInt(value) === 0)) || this.removeEmpty || (this.acceptEmpty || acceptEmpty)) {\n          if (!EditableText._blockOkayEvent) { \n            EditableText._blockOkayEvent = true;  \n            ok.call(this, value, evt, tmpl); // EditableText._linkify(value)\n            Meteor.defer(function () {\n              EditableText._blockOkayEvent = false;\n            });\n          }\n          else { // In case this value is set to true for some strange reason\n            EditableText._blockOkayEvent = false;    \n          }\n        }\n        else {\n          cancel.call(this, value, evt, tmpl);\n        }\n      }\n    };\n  return events;\n};\n\nEditableText._activateInput = function (input, dontSelect) {\n  if (input !== null) {\n    input.focus();\n    if (typeof dontSelect !== 'undefined' && dontSelect) {\n      return;\n    }\n    input.select();\n  }\n  else {\n    console.log('Input was null');  \n  }\n};\n\nEditableText._extractNumber = function (raw) {\n  if (typeof raw !== 'undefined') {\n    var numbers = raw.match(/[0-9]+/);\n    if (numbers) {\n      return parseInt(numbers[0], 10);\n    }\n  }\n  return 0;\n}\n\nEditableText._makeUpdate = function (value, isEscape, evtType) {\n  // value has already been trimmed with $.trim()\n  var currentValue = (this.editingValue || this.value) || EditableText._drillDown(this.context, this.field);\n  var type = this.type || 'string';\n  var keepZero = false;\n  switch (type) {\n    case 'number' :\n\t  if (value !== '') {\n        var rawNewValue = EditableText._extractNumber(value);\n        var newValue = rawNewValue && parseInt(rawNewValue) || 0;\n\t\tkeepZero = true;\n\t  }\n\t  else {\n\t\tvar newValue = 0;\n\t  }\n\t  if (currentValue !== undefined) {\n        currentValue = currentValue && parseInt(currentValue) || 0;\n\t  }\n      break;\n    default :\n      var newValue = value.replace(/mml:/g, \"\"); // For cleaning up mathml pasted from msword\n      currentValue = _.isString(currentValue) && currentValue.replace(/<br \\/>/g, \"<br>\") || '';\n\t  currentValue = EditableText._removeEntities(currentValue);\n\t  newValue = EditableText._removeEntities(newValue);\n      break;\n  }\n  var updatedValue = {};\n  updatedValue[this.field] = newValue; // console.log(\"newValue:\",newValue); console.log(\"currentValue:\",currentValue);\n  // Sometimes we don't want the actual field's value, we want whatever was passed in to the template as the 'value' keyword to be used to compare against\n  if (newValue !== currentValue || (!(newValue || (this.type === 'number' && newValue === 0 && keepZero)) && this.removeEmpty && !(this.acceptEmpty && evtType === 'focusout'))) {\n    if (!(newValue || (this.type === 'number' && newValue === 0 && keepZero)) && this.removeEmpty && !(this.acceptEmpty && evtType === 'focusout')) {\n      if ((isEscape || evtType === 'focusout') && (this.acceptEmpty || currentValue)) { // isEscape is an alternative for (isEscape || evtType === 'focusout') if we want to allow focusout to remove an item\n        return;  \n      }\n      EditableText.remove.call(this,Mongo.Collection.get(this.collection),this.context);\n    }\n    else if (!isEscape && (newValue !== currentValue) && ((newValue || (this.type === 'number' && newValue === 0)) || this.acceptEmpty || (this.wysiwyg && this.acceptEmpty !== false))) { // wysiwyg accepts empty by default unless explicitly told not to\n      // Make the update\n      EditableText.update.call(this, Mongo.Collection.get(this.collection), this.context, {$set: updatedValue});\n    }\n  }\n}\n\n// *******\n// HELPERS\n// *******\n\nTemplate.editable_text_widget.helpers({\n    \n  value : function() {\n\tvar value = (this.editingValue !== 'undefined') ? this.editingValue : this.value;\n    return (this.type === 'number' && value === 0) ? 0 : value || EditableText._drillDown(this.context,this.field); \n  },\n  \n  editing : function() {\n    return Blaze._templateInstance().selected.get(); \n  },\n  \n  textarea : function() {\n    return (this.textarea && !this.wysiwyg) || (this.wysiwyg && !EditableText.wysiwyg);  \n  },\n  \n  isWysiwyg : function() {\n    return EditableText.wysiwyg && this.wysiwyg;\n  },\n  \n  wysiwygContent : function() {\n    var value = this.value || EditableText._drillDown(this.context,this.field);\n    return value && new Spacebars.SafeString(value.replace(/\\n/g,'<br>')) || \"\";  \n  },\n  \n  inputValue : function() {\n\tvar val = (this.editingValue !== undefined) ? this.editingValue : this.value;\n    var value = (this.type === 'number' && val === 0) ? 0 : val || EditableText._drillDown(this.context,this.field);\n    return (this.type === 'number' && value === 0) ? 0 : value && value.toString() || \"\";\n  },\n  \n  substitute : function(userCanNotEdit) {\n    var substitute = !(this.value || EditableText._drillDown(this.context,this.field)) && ((userCanNotEdit) ? (this.emptyText && Spacebars.SafeString(this.emptyText.toString())) : (this.substitute && Spacebars.SafeString(this.substitute.toString())));\n\treturn substitute;\n  },\n  \n  title : function() {\n    return this.title || ((this.eventType === 'dblclick') ? 'double click' : 'click') + ' to edit'; \n  },\n  \n  canEditText : function() {\n    var userCanEdit = EditableText.userCanEdit.call(this,this.context,Mongo.Collection.get(this.collection));\n    return (typeof this.userCanEdit !== 'undefined') ? (this.userCanEdit && userCanEdit) : userCanEdit;\n  },\n  \n  content : function() {\n    var value = (typeof this.value !== 'undefined') ? this.value : EditableText._drillDown(this.context,this.field);\n    var val = (_.isString(value)) ? (((typeof this.trustHtml !== 'undefined' && this.trustHtml || EditableText.trustHtml) || (this.wysiwyg && !EditableText.wysiwyg)) && new Spacebars.SafeString(value.replace(/\\n/g,'<br>')) || value) : ((value || value === 0) ? value.toString() : \"\");\n    return val; \n  },\n  \n  trustHtml : function() {\n    return typeof this.trustHtml !== 'undefined' && this.trustHtml || EditableText.trustHtml;\n  },\n  \n  toolsPosition : function(pos) {\n    return this.toolbarPosition === pos;\n  },\n  \n  initOptions : function() {\n    var data = this;\n\tvar derivedOptions = (data.derivedOptions) ? EditableText._callback.call(data,'derivedOptions',data) : {};\n\tvar opts = _.extend(data.options || {}, _.isObject(derivedOptions) && derivedOptions || {});\n    if (opts) {\n      _.each(opts, function (value, key) {\n        if (data[key] === undefined) {\n          data[key] = value;\n        }\n      });\n\t  var context = opts.context || opts.doc || opts.document || opts.obj || opts.object || opts.data || opts.dataContext;\n      if (context !== undefined) {\n        data.context = context;\n      }\n    }\n\treturn data; \n  },\n  \n  controlTemplate : function () {\n\treturn this.editor && EditableText.editors[this.editor] && EditableText.editors[this.editor].template;\n  },\n  \n  controlData : function () {\n\treturn this;  \n  }\n  \n});\n\n\n// ******\n// EVENTS\n// ******\n\nTemplate.body.events({\n  'click .editable-text-trigger, mousedown .editable-text-trigger, dblclick .editable-text-trigger' : function(evt) {\n\tif (!EditableText.__blockEditEvent) {\n      $(evt.currentTarget).find('.editable-text').trigger(evt.type);\n\t}\n\telse {\n\t  EditableText.__blockEditEvent = false;\t\n\t}\n  }\n});\n\nEditableText.okCancelEvents = {};\n\nEditableText.okCancelEvents.ok = function (value, evt, tmpl) {\n  evt.stopImmediatePropagation();\n  evt.stopPropagation();\n  var isEscape = false;\n  EditableText._makeUpdate.call(this, value, isEscape, evt.type);\n  tmpl.selected.set(false);\n  EditableText._callback.call(this, 'onStopEditing', tmpl.data.context);\n}\n\nEditableText.okCancelEvents.cancel = function (value, evt, tmpl) {\n  evt.stopImmediatePropagation();\n  // Check for removeEmpty update, in case a document has been auto inserted and user clicks escape\n  // But set the flag isEscape so regular updates are not made\n  var isEscape = true;\n  EditableText._makeUpdate.call(this, value, isEscape);\n  tmpl.selected.set(false);\n  EditableText._callback.call(this, 'onStopEditing', tmpl.data.context);\n}\n  \nEditableText.editing_key_press = function(elem, inputClass) {\n  if (EditableText.editing_key_press.fakeEl === undefined) {\n    EditableText.editing_key_press.fakeEl = $('<span class=\"' + (inputClass || '') + '\">').hide().appendTo(document.body);\n  }\n  var el = $(elem);\n  EditableText.editing_key_press.fakeEl.text(el.val());\n  var width = EditableText.editing_key_press.fakeEl.width() + 20;\n  el.width(width);\n  el.css('min-width', width);\n}\n\nTemplate.editable_text_widget.events(EditableText._okCancelEvents('.wide-text-edit', EditableText.okCancelEvents));\nTemplate.editable_text_widget.events({\n  'keyup .wide-text-edit' : function (evt) {\n\tif (this.editor) {\n\t  return;\t\n\t}\n\tif (this.autoResize) {\n\t  EditableText.editing_key_press(evt.target, this.inputClass);\t\n\t}\n  }\n});\nTemplate.editable_text_widget.events(EditableText._okCancelEvents('.text-area-edit', EditableText.okCancelEvents));\nTemplate.editable_text_widget.events({\n  'mousedown .editable-text, click .editable-text, dblclick .editable-text' : function (evt, tmpl) {\n\tif (this.editor) {\n\t  return;\t\n\t}\n\tif (this.stopPropagation) {\n      evt.stopImmediatePropagation();\n      evt.stopPropagation();\n\t}\n\tEditableText.__blockEditEvent = true;\n    // This is the click event that opens the field for editing\n    var eventType = this.eventType || ((EditableText.wysiwyg && this.wysiwyg) ? 'mousedown' : 'click');\n    if (eventType !== evt.type) {\n      return;    \n    }\n    var textarea = (this.textarea && !this.wysiwyg) || (this.wysiwyg && !EditableText.wysiwyg);\n    var wysiwyg = EditableText.wysiwyg && this.wysiwyg;\n    var obj = this.context;\n    var Collection = Mongo.Collection.get(this.collection);\n    if (this.autoInsert && obj && !obj._id && _.isObject(obj) && EditableText.userCanEdit.call(this, obj, Collection)) { // This is quite involved -- you need an object with all context info, but no _id field for auto-creation to occur\n      if (typeof this.value !== 'undefined' && this.value !== obj[this.field]) {\n        obj[this.field] = this.value;  \n      }\n      // Create an object\n      EditableText.insert.call(this, Collection, obj);\n\t  EditableText.__blockEditEvent = false;\n      evt.stopImmediatePropagation();\n      evt.stopPropagation();\n      return;\n    }\n    if (obj && !tmpl.selected.get()) {\n      if (EditableText.userCanEdit.call(this, obj, Collection)) {\n        // document.activeElement.blur(); // Make sure the focusout event fires first when switching editable text objects, so that the first one gets saved properly\n        tmpl.selected.set(true);\n        Tracker.flush();\n        if (!wysiwyg) {\n          EditableText._activateInput(tmpl.$((textarea) ? 'textarea' :  'input'), this.dontSelectAll || false); // textarea\n\t\t  if (this.autoResize && !textarea) {\n\t\t\tEditableText.editing_key_press(tmpl.$('.wide-text-edit'), this.inputClass);\n\t\t  }\n        }\n\t\tEditableText._callback.call(this, 'onStartEditing', tmpl.data.context);\n      }\n    }\n\tEditableText.__blockEditEvent = false;\n  }\n});\n\nTemplate.editable_text_widget.created = function () {\n  this.selected = new ReactiveVar();\n}","if (typeof EditableText === 'undefined') {\n  EditableText = {};\n}\n\n\n// ******************************************\n// CONFIG that affects BOTH CLIENT AND SERVER\n// ******************************************\n\nEditableText.userCanEdit = function(doc,Collection) {\n  // e.g. return doc.user_id = Meteor.userId();\n  return true;    \n}\n\nEditableText.useTransactions = (typeof tx !== 'undefined' && _.isObject(tx.Transactions)) ? true : false;\nEditableText.clientControlsTransactions = false;\n\nEditableText.maximumImageSize = 0; // Can't put image data in the editor by default\n\n// This is the set of defaults for sanitizeHtml on the server (as set by the library itself)\n// Required on the client for consistency of filtering on the paste event\nif (Meteor.isClient) {\n  sanitizeHtml = {};\n  sanitizeHtml.defaults = {\n    allowedTags: [ 'h3', 'h4', 'h5', 'h6', 'blockquote', 'p', 'a', 'ul', 'ol', 'nl', 'li', 'b', 'i', 'strong', 'em', 'strike', 'code', 'hr', 'br', 'div', 'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre' ],\n    allowedAttributes: { a: [ 'href', 'name', 'target' ] },\n    selfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],\n    allowedSchemes: [ 'http', 'https', 'ftp', 'mailto' ]  \n  };    \n}\n\nMeteor.startup(function () {\n  // The startup block is to allow apps to overwrite the sanitizeHtml defaults\n  EditableText.allowedHtml = {\n\tallowedTags: sanitizeHtml.defaults.allowedTags.concat(['sub', 'sup', 'font', 'u', 's', 'span']),\n\tallowedAttributes: _.extend(sanitizeHtml.defaults.allowedAttributes, {\n\t  font : ['size', 'face'],\n\t  div : ['align', 'style', 'class'],\n\t  span: ['style', 'class'],\n\t  table: ['style', 'class'],\n\t  td : ['rowspan', 'colspan', 'style', 'class'],\n\t  a: ['href', 'target', 'class'],\n\t  i: ['class']\n\t}),\n\tallowedSchemes:['http', 'https', 'ftp', 'mailto']\n  }\n});;\n\n\n// ******************************************\n// Functions that are intended for use in app\n// ******************************************\n\n// Function for setting multiple config variable via a hash\n\nEditableText.config = function(config) {\n  if (_.isObject(config)) {\n     _.each(config,function(val,key) {\n       if (_.contains(['userCanEdit','insert','update','remove'],key)) {\n         if (_.isFunction(val)) {\n           EditableText[key] = val;\n         }\n         else {\n           throw new Meteor.Error(key + ' must be a function');\n         }\n       }\n       if (_.contains(['useTransactions','clientControlsTransactions','saveOnFocusout','trustHtml','useMethods'],key)) {\n         if (_.isBoolean(val)) {\n           EditableText[key] = val;\n         }\n         else {\n           throw new Meteor.Error(key + ' must be a boolean');\n         }\n       }\n       if (_.contains(['collection2Options'], key)) {\n         if (_.isObject(val)) {\n            EditableText[key] = val;\n         }\n       }\n     });\n  }\n  else {\n    throw new Meteor.Error('Editable text config object must be a hash of key value pairs. Config not changed.');  \n  }\n}\n\n// Function for registering callbacks\n\nEditableText.registerCallbacks = function(obj) {\n  if (_.isObject(obj)) {\n    _.each(obj,function(val,key) {\n      if (_.isFunction(val)) {\n        EditableText._callbacks[key] = val;\n      }\n      else {\n        throw new Meteor.Error('Callbacks need to be functions. You passed a ' + typeof(val) + '.');    \n      }\n    });\n  }\n  else {\n    throw new Meteor.Error('You must pass an object to register callbacks');  \n  }\n}\n\n\n// *********************************\n// INTERNAL PROPERTIES AND FUNCTIONS\n// *********************************\n\nEditableText._callbacks = {};\n\nEditableText._mutatedDocIsObject = function (mutatedDoc) {\n  return _.isObject(mutatedDoc) && !_.isArray(mutatedDoc) && !_.isDate(mutatedDoc) && !_.isFunction(mutatedDoc); // Just want real key-value pair type objects\n}\n\nEditableText._callback = function(callback, doc, originalValue) {\n  // Note: 'beforeUpdate' and 'beforeInsertMultiple' callbacks are special-cased to use return values of any type, not just objects\n  // originalValue is only set on beforeUpdate and beforeInsertMultiple callbacks. It is of the form { value: <actual original value> }\n  // otherwise originalValue should be undefined\n  callback = String(callback);\n  var self = this;\n  var callbackRan = false;\n  if (self[callback] && _.isString(self[callback])) {\n    var mutatedDoc = EditableText._executeCallback(self[callback], self, doc, originalValue);\n\tcallbackRan = true;\n\tvar mutatedDocIsObject = EditableText._mutatedDocIsObject(mutatedDoc);\n\tif (!originalValue && !mutatedDocIsObject) {\n\t  throw new Meteor.Error('Wrong type returned', 'Your callback function \"' + callback + '\" returned a ' + typeof mutatedDoc + '. An object was expected.');\t\n\t}\n    doc = (originalValue) ? mutatedDoc : mutatedDocIsObject && mutatedDoc || doc;\n  }\n  if (originalValue) {\n\t// if the callback hasn't run, then the\n\t// doc is still the whole document,\n\t// not the new value for the field\n\tif (!callbackRan) {\n\t  doc = originalValue.value;\t\n\t}\n\tif (callbackRan && mutatedDocIsObject && (_.has(doc, '$set') || _.has(doc, '$addToSet') || _.has(doc, '$push'))) {\n\t  return {modifier: doc};\n\t}\n\telse {\n\t  return {value: doc};  \n\t}\n  }\n  return doc;\n}\n\nEditableText._executeCallback = function(callbackFunctionName, self, doc, originalValue) { // originalValue.value is the default to return if no updates have been made\n  var mutatedDoc = (originalValue && {value: originalValue.value}) || doc;\n  var callbackFunction = EditableText._callbacks[callbackFunctionName];\n  if (callbackFunction && _.isFunction(callbackFunction)) {\n    callbackMutatedDoc = callbackFunction.call(self, doc, Mongo.Collection.get(self.collection), originalValue && originalValue.value || undefined, originalValue && originalValue.modifier || undefined);\n\tif (!_.isUndefined(callbackMutatedDoc)) {\n\t  mutatedDoc = callbackMutatedDoc;\n\t}\n  }\n  else {\n    throw new Meteor.Error('Callback not a function', 'Could not execute callback. Reason: ' + ((callbackFunction) ? '\"' + callbackFunctionName + '\" is not a function, it\\'s a ' + typeof(callbackFunction) + '.' : 'no callback function called \"' + callbackFunctionName + '\" has been registered via EditableText.registerCallbacks.'));    \n  }\n  return mutatedDoc;\n}\n\nEditableText._drillDown = function(obj,key) {\n  return Meteor._get.apply(null,[obj].concat(key.split('.')));\n}\n\nEditableText._allowedHtml = function() {\n  var allowed = EditableText.allowedHtml;\n  if (EditableText.maximumImageSize && _.isNumber(EditableText.maximumImageSize) && allowed) {\n    allowed.allowedTags.push('img');\n    allowed.allowedAttributes.img = ['src'];\n    allowed.allowedSchemes.push('data'); \n  }\n  return allowed;\n}\n\n\n// *************\n// UPDATE METHOD\n// *************\n\nMeteor.methods({\n  _editableTextWrite : function (action, data, modifier, transaction) {\n    check(action, String);\n    check(data, Object);\n    check(data.collection, String);\n    check(data.context, (typeof FS !== \"undefined\" && FS.File) ? Match.OneOf(Object, FS.File) : Object);\n    check(modifier, (action === 'update') ? Object : null);\n    check(transaction, Boolean);\n    check(data.objectTypeText, Match.OneOf(String, undefined));\n    var hasPackageCollection2 = !!Package['aldeed:collection2'];\n    var hasPackageSimpleSchema = !!Package['aldeed:simple-schema'];\n    var Collection = Mongo.Collection.get(data.collection);\n    var c2optionsHashRequired = hasPackageCollection2 && hasPackageSimpleSchema && _.isFunction(Collection.simpleSchema) && Collection._c2;\n    if (Collection && EditableText.userCanEdit.call(data, data.context, Collection)) {\n\t  if (Meteor.isServer) {\n        if (_.isBoolean(EditableText.useTransactions) && !EditableText.clientControlsTransactions) {\n          transaction = EditableText.useTransactions;\n        }\n      }\n      if (typeof tx === 'undefined') {\n        transaction = false;    \n      }\n      var setStatus = function (err, res) {\n        data.status = {error: err, result: res};    \n      }\n\t  var options = (transaction) ? {instant: true} : {};\n      if (c2optionsHashRequired) {\n        options = _.extend(options, EditableText.collection2options || {});    \n      }\n      switch (action) {\n        case 'insert' :\n          if (Meteor.isServer) {\n            // run all string fields through sanitizeHtml\n            data.context = EditableText.sanitizeObject(data.context);\n          }\n          if (transaction) {\n            if (data.objectTypeText || data.transactionInsertText) {\n              tx.start(data.transactionInsertText || 'add ' + data.objectTypeText);\n            }\n            data.context = EditableText._callback.call(data, 'beforeInsert', data.context) || data.context;\n            var new_id = tx.insert(Collection, data.context, options, setStatus);\n            EditableText._callback.call(data, 'afterInsert', Collection.findOne({_id: new_id}));\n            if (data.objectTypeText || data.transactionInsertText) {\n              tx.commit();\n            }\n          }\n          else {\n            data.context = EditableText._callback.call(data,'beforeInsert',data.context) || data.context;\n            var new_id = (c2optionsHashRequired) ? Collection.insert(data.context,options,setStatus) : Collection.insert(data.context, setStatus);\n            EditableText._callback.call(data, 'afterInsert', Collection.findOne({_id: new_id}));\n          }\n          return new_id;\n          break;\n        case 'update' :\n          if (Meteor.isServer) {\n            var newValue, sanitized = false;\n            if (modifier[\"$set\"] && _.isString(modifier[\"$set\"][data.field])) {\n            // run through sanitizeHtml\n              newValue = modifier[\"$set\"][data.field] = EditableText.sanitizeString(modifier[\"$set\"][data.field], data.wysiwyg || !!data.editor);\n              sanitized = true;\n            }\n            if (modifier[\"$set\"] && _.isArray(modifier[\"$set\"][data.field])) {\n              newValue = modifier[\"$set\"][data.field] = _.map(modifier[\"$set\"][data.field],function (str) {return EditableText.sanitizeString(str, data.wysiwyg || !!data.editor);});\n              sanitized = true;\n            }\n            if (modifier[\"$set\"] && _.isNumber(modifier[\"$set\"][data.field])) {\n              newValue = modifier[\"$set\"][data.field];\n              sanitized = true;    \n            }\n            if (modifier[\"$addToSet\"] && _.isString(modifier[\"$addToSet\"][data.field])) {\n              newValue = modifier[\"$addToSet\"][data.field] = EditableText.sanitizeString(modifier[\"$addToSet\"][data.field], data.wysiwyg || !!data.editor);\n              sanitized = true;    \n            }\n            if (modifier[\"$push\"] && _.isString(modifier[\"$push\"][data.field])) {\n              newValue = modifier[\"$push\"][data.field] = EditableText.sanitizeString(modifier[\"$push\"][data.field], data.wysiwyg || !!data.editor);\n              sanitized = true;    \n            }\n            if (!sanitized) {\n              throw new Meteor.Error('Wrong data type sent for update');\n\t\t\t  return; \n            }\n          }\n          else {\n            newValue = (modifier[\"$set\"] && (modifier[\"$set\"][data.field] || (data.type !== 'number' && modifier[\"$set\"][data.field] === '') || (data.type === 'number' && modifier[\"$set\"][data.field] === 0))) || (modifier[\"$addToSet\"] && modifier[\"$addToSet\"][data.field]) || (modifier[\"$push\"] && modifier[\"$push\"][data.field]);\n          }\n          data.newValue = newValue;\n          data.oldValue = EditableText._drillDown(data.context, data.field);\n\t\t  var callbackModifier = function (modifier, key, val) {\n\t\t\t/*if (val === undefined) {\n\t\t\t  return modifier;\n\t\t\t}*/\n\t\t\tvar modifierTypes = [\"$set\", \"$addToSet\", \"$push\"];\n\t\t\tvar modType = _.find(modifierTypes, function (mt) {\n\t\t\t  return _.has(modifier, mt);\n\t\t\t});\n\t\t\tif (modType) {\n\t\t\t  modifier[modType][key] = val;\n\t\t\t}\n\t\t\treturn modifier;\n\t\t  }\n          if (transaction) {\n            if (data.transactionUpdateText || data.objectTypeText) {\n              tx.start(data.transactionUpdateText || 'update ' + data.objectTypeText);\n            }\n            var newVal = EditableText._callback.call(data,'beforeUpdate',data.context, {value: data.newValue, modifier: modifier}); // By setting the fourth parameter, we are expecting a value, not the whole doc, to be returned from the callback\n\t\t\tmodifier = callbackModifier(newVal.modifier || modifier, data.field, newVal.value);\n            tx.update(Collection,data.context._id, modifier, options, setStatus);\n            EditableText._callback.call(data, 'afterUpdate', Collection.findOne({_id: data.context._id}));\n            if (data.transactionUpdateText || data.objectTypeText) {\n              tx.commit();\n            }\n          }\n          else {\n            var newVal = EditableText._callback.call(data, 'beforeUpdate', data.context, {value: data.newValue, modifier: modifier});\n\t\t\tmodifier = callbackModifier(newVal.modifier || modifier, data.field, newVal.value);\n            if (c2optionsHashRequired) {\n              Collection.update({_id: data.context._id}, modifier, options, setStatus);\n            }\n            else {\n              Collection.update({_id: data.context._id}, modifier, setStatus);\n            }\n            EditableText._callback.call(data, 'afterUpdate', Collection.findOne({_id: data.context._id}));\n          }\n          break;\n        case 'remove' :\n          if (transaction) {\n            if (data.transactionRemoveText || data.objectTypeText) {\n              tx.start(data.transactionRemoveText || 'remove ' + data.objectTypeText);\n            }\n            data.context = EditableText._callback.call(data, 'beforeRemove', data.context) || data.context;\n            tx.remove(Collection, data.context._id, {instant: true}, setStatus);\n            EditableText._callback.call(data, 'afterRemove', data.context);\n            if (data.transactionRemoveText || data.objectTypeText) {\n              tx.commit();\n            } \n          }\n          else {\n            data.context = EditableText._callback.call(data, 'beforeRemove', data.context) || data.context;\n            Collection.remove({_id: data.context._id}, setStatus);\n            EditableText._callback.call(data, 'afterRemove', data.context);\n          }\n          break;  \n      }\n    }\n  }\n});"]}